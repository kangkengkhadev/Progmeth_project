Index: src/logic/LowGhost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic;\n\n\nimport util.Config;\n\npublic abstract class LowGhost extends Ghost{\n    public LowGhost(double x, double y, double width, double height, String imgPath) {\n        super(x, y, width, height, imgPath);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/LowGhost.java b/src/logic/LowGhost.java
--- a/src/logic/LowGhost.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/logic/LowGhost.java	(date 1713966062205)
@@ -4,7 +4,7 @@
 import util.Config;
 
 public abstract class LowGhost extends Ghost{
-    public LowGhost(double x, double y, double width, double height, String imgPath) {
-        super(x, y, width, height, imgPath);
+    public LowGhost(double x, double y, double width, double height, double speed, String imgPath) {
+        super(x, y, width, height, speed, imgPath);
     }
 }
Index: src/logic/Ghost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic;\n\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.image.Image;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.paint.Color;\nimport util.Config;\nimport util.InputUtility;\n\nimport java.util.ArrayList;\n\npublic abstract class Ghost extends Entity implements Collidable  {\n    protected Image sprite;\n    protected Vector2D velocity;\n    protected Vector2D target;\n\n    public Ghost(double x, double y, double width, double height, String imgPath) {\n        super(x, y, width, height);\n        // Load the image\n        sprite = new Image(ClassLoader.getSystemResource(imgPath).toString());\n        // Initialize the velocity to 0 in both x and y direction\n        velocity = new Vector2D(Config.GHOST_SPEED, 0);\n        target = new Vector2D(0, 0);\n    }\n\n    @Override\n    public int getZIndex() {\n        return Config.GHOST_Z_INDEX;\n    }\n\n    @Override\n    public void draw(GraphicsContext gc) {\n        // Draw the sprite at the current position scaled to the unit width\n        gc.drawImage(sprite,\n                position.getX() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getXPadding(),\n                position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),\n                width,\n                height);\n    }\n\n    protected abstract void updateTarget();\n\n    private void changeVelocity() {\n        Vector2D currentDiscretePosition = new Vector2D((int)position.getX(), (int)position.getY());\n        Map map = GameController.getInstance().getMap();\n        if (position.equals(currentDiscretePosition)) {\n            Direction currentDirection = velocity.getCurrentDirection();\n            boolean isWallLeft = map.isWall(currentDiscretePosition.getX() - 1, currentDiscretePosition.getY());\n            boolean isWallRight = map.isWall(currentDiscretePosition.getX() + 1, currentDiscretePosition.getY());\n            boolean isWallUp = map.isWall(currentDiscretePosition.getX(), currentDiscretePosition.getY() - 1);\n            boolean isWallDown = map.isWall(currentDiscretePosition.getX(), currentDiscretePosition.getY() + 1);\n            Direction[] directions = {Direction.LEFT, Direction.RIGHT, Direction.UP, Direction.DOWN};\n            Vector2D[] directionOffsets = {new Vector2D(-Config.GHOST_SPEED, 0), new Vector2D(Config.GHOST_SPEED, 0), new Vector2D(0, -Config.GHOST_SPEED), new Vector2D(0, Config.GHOST_SPEED)};\n            int bestDirectionIndex = -1;\n            double bestDistance = Double.MAX_VALUE;\n            for (int i = 0; i < 4; i++) {\n                Direction dir = directions[i];\n                Vector2D offset = directionOffsets[i];\n                if ((velocity.isSameAxis(offset) && dir != currentDirection)\n                        || dir == Direction.LEFT && isWallLeft\n                        || dir == Direction.RIGHT && isWallRight\n                        || dir == Direction.UP && isWallUp\n                        || dir == Direction.DOWN && isWallDown) {\n                    continue;\n                }\n\n                Vector2D nextDiscretePosition = new Vector2D(currentDiscretePosition.getX() + offset.getX(), currentDiscretePosition.getY() + offset.getY());\n                Vector2D vec = new Vector2D(target.getX() - nextDiscretePosition.getX(), target.getY() - nextDiscretePosition.getY());\n\n                if (vec.getLength() < bestDistance) {\n                    bestDistance = vec.getLength();\n                    bestDirectionIndex = i;\n                }\n            }\n\n            if (bestDirectionIndex != -1) {\n                velocity.setX(directionOffsets[bestDirectionIndex].getX());\n                velocity.setY(directionOffsets[bestDirectionIndex].getY());\n            } else {\n                velocity.setX(-velocity.getX());\n                velocity.setY(-velocity.getY());\n            }\n        }\n    }\n\n    private void move(double delta) {\n        Direction currentDirection = velocity.getCurrentDirection();\n        Vector2D currentDiscretePosition = new Vector2D((int)position.getX(), (int)position.getY());\n        if (currentDirection == Direction.LEFT || currentDirection == Direction.RIGHT) {\n            setY(currentDiscretePosition.getY());\n            if (currentDirection == Direction.LEFT) {\n                Vector2D vec = new Vector2D(currentDiscretePosition.getX() - position.getX(), 0);\n                if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\n                    setX(currentDiscretePosition.getX());\n                    return;\n                }\n            } else {\n                Vector2D vec = new Vector2D(currentDiscretePosition.getX() + 1 - position.getX(), 0);\n                if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\n                    setX(currentDiscretePosition.getX() + 1);\n                    return;\n                }\n            }\n            setX(position.getX() + velocity.getX() * GameController.getInstance().getGamePanel().getUnitWidth() * delta);\n        } else {\n            setX(currentDiscretePosition.getX());\n            if (currentDirection == Direction.UP) {\n                Vector2D vec = new Vector2D(0, currentDiscretePosition.getY() - position.getY());\n                if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\n                    setY(currentDiscretePosition.getY());\n                    return;\n                }\n            } else {\n                Vector2D vec = new Vector2D(0, currentDiscretePosition.getY() + 1 - position.getY());\n                if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\n                    setY(currentDiscretePosition.getY() + 1);\n                    return;\n                }\n            }\n            setY(position.getY() + velocity.getY() * GameController.getInstance().getGamePanel().getUnitWidth() * delta);\n        }\n    }\n\n    public void update(double delta) {\n        updateTarget();\n        changeVelocity();\n        move(delta);\n    }\n\n    @Override\n    public Rectangle getCollisionBox() {\n        GamePanel gamePanel = GameController.getInstance().getGamePanel();\n        return new Rectangle(position.getX() * gamePanel.getUnitWidth() + gamePanel.getXPadding(), position.getY() * gamePanel.getUnitWidth() + gamePanel.getYPadding(), width, height);\n    }\n}\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/Ghost.java b/src/logic/Ghost.java
--- a/src/logic/Ghost.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/logic/Ghost.java	(date 1713966062204)
@@ -13,14 +13,16 @@
     protected Image sprite;
     protected Vector2D velocity;
     protected Vector2D target;
+    private double speed;
 
-    public Ghost(double x, double y, double width, double height, String imgPath) {
+    public Ghost(double x, double y, double width, double height, double speed, String imgPath) {
         super(x, y, width, height);
         // Load the image
         sprite = new Image(ClassLoader.getSystemResource(imgPath).toString());
         // Initialize the velocity to 0 in both x and y direction
-        velocity = new Vector2D(Config.GHOST_SPEED, 0);
+        velocity = new Vector2D(speed, 0);
         target = new Vector2D(0, 0);
+        this.speed = speed;
     }
 
     @Override
@@ -36,9 +38,19 @@
                 position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),
                 width,
                 height);
+
+        gc.setFill(switch (this.getClass().getSimpleName()) {
+            case "OrangeGhost" -> Color.ORANGE;
+            case "YellowGhost" -> Color.YELLOW;
+            case "GreenGhost" -> Color.GREEN;
+            default -> Color.BLACK;
+        });
+
+        gc.fillRect((target.getX() + 0.5) * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getXPadding(),
+                (target.getY() + 0.5) * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),
+                5,
+                5);
     }
-
-    protected abstract void updateTarget();
 
     private void changeVelocity() {
         Vector2D currentDiscretePosition = new Vector2D((int)position.getX(), (int)position.getY());
@@ -50,7 +62,7 @@
             boolean isWallUp = map.isWall(currentDiscretePosition.getX(), currentDiscretePosition.getY() - 1);
             boolean isWallDown = map.isWall(currentDiscretePosition.getX(), currentDiscretePosition.getY() + 1);
             Direction[] directions = {Direction.LEFT, Direction.RIGHT, Direction.UP, Direction.DOWN};
-            Vector2D[] directionOffsets = {new Vector2D(-Config.GHOST_SPEED, 0), new Vector2D(Config.GHOST_SPEED, 0), new Vector2D(0, -Config.GHOST_SPEED), new Vector2D(0, Config.GHOST_SPEED)};
+            Vector2D[] directionOffsets = {new Vector2D(-1, 0), new Vector2D(1, 0), new Vector2D(0, -1), new Vector2D(0, 1)};
             int bestDirectionIndex = -1;
             double bestDistance = Double.MAX_VALUE;
             for (int i = 0; i < 4; i++) {
@@ -65,6 +77,7 @@
                 }
 
                 Vector2D nextDiscretePosition = new Vector2D(currentDiscretePosition.getX() + offset.getX(), currentDiscretePosition.getY() + offset.getY());
+                if (nextDiscretePosition.equals(new Vector2D(23, 10))) continue;
                 Vector2D vec = new Vector2D(target.getX() - nextDiscretePosition.getX(), target.getY() - nextDiscretePosition.getY());
 
                 if (vec.getLength() < bestDistance) {
@@ -74,8 +87,8 @@
             }
 
             if (bestDirectionIndex != -1) {
-                velocity.setX(directionOffsets[bestDirectionIndex].getX());
-                velocity.setY(directionOffsets[bestDirectionIndex].getY());
+                velocity.setX(directionOffsets[bestDirectionIndex].getX() * speed);
+                velocity.setY(directionOffsets[bestDirectionIndex].getY() * speed);
             } else {
                 velocity.setX(-velocity.getX());
                 velocity.setY(-velocity.getY());
@@ -121,6 +134,8 @@
         }
     }
 
+    protected abstract void updateTarget();
+
     public void update(double delta) {
         updateTarget();
         changeVelocity();
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"99fe93bf-1359-4ca8-a9f4-4cc9711ecb69\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/logic/Map.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/logic/Map.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/logic/TileMap.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/logic/TileMap.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Interface\" />\r\n        <option value=\"Enum\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\n  &quot;customColor&quot;: &quot;&quot;,\n  &quot;associatedIndex&quot;: 7\n}</component>\r\n  <component name=\"ProjectId\" id=\"2f0MYbgF6HSOOSY4gqZG5JiDsgL\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\n  \"keyToString\": {\n    \"Application.Main.executor\": \"Run\",\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\n    \"SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\n    \"git-widget-placeholder\": \"main\",\n    \"ignore.virus.scanning.warn.message\": \"true\",\n    \"kotlin-language-version-configured\": \"true\",\n    \"last_opened_file_path\": \"D:/Progmeth_project\",\n    \"project.structure.last.edited\": \"Global Libraries\",\n    \"project.structure.proportion\": \"0.0\",\n    \"project.structure.side.proportion\": \"0.0\",\n    \"settings.editor.selected.configurable\": \"preferences.lookFeel\"\n  }\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"project\" />\r\n      <option name=\"VM_PARAMETERS\" value=\"--module-path $USER_HOME$/Downloads/javafx-sdk-21.0.3/lib --add-modules javafx.controls,javafx.fxml,javafx.graphics,javafx.media\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"99fe93bf-1359-4ca8-a9f4-4cc9711ecb69\" name=\"Changes\" comment=\"\" />\r\n      <created>1712917985604</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1712917985604</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/.idea/workspace.xml	(date 1713966074704)
@@ -5,9 +5,21 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="99fe93bf-1359-4ca8-a9f4-4cc9711ecb69" name="Changes" comment="">
+      <change afterPath="$PROJECT_DIR$/src/logic/PacmanState.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+<<<<<<< HEAD
       <change beforePath="$PROJECT_DIR$/src/logic/Map.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/Map.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/logic/TileMap.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/TileMap.java" afterDir="false" />
+=======
+      <change beforePath="$PROJECT_DIR$/src/logic/GameController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/GameController.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/Ghost.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/Ghost.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/GreenGhost.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/GreenGhost.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/LowGhost.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/LowGhost.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/OrangeGhost.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/OrangeGhost.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/Pacman.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/Pacman.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/logic/YellowGhost.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/logic/YellowGhost.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/util/Config.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/util/Config.java" afterDir="false" />
+>>>>>>> refs/remotes/origin/main
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -18,8 +30,8 @@
     <option name="RECENT_TEMPLATES">
       <list>
         <option value="Interface" />
-        <option value="Enum" />
         <option value="Class" />
+        <option value="Enum" />
       </list>
     </option>
   </component>
Index: src/logic/YellowGhost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic;\r\n\r\npublic class YellowGhost extends LowGhost {\r\n    public YellowGhost(double x, double y, double width, double height, String imgPath) {\r\n        super(x, y, width, height, imgPath);\r\n    }\r\n\r\n    @Override\r\n    protected void updateTarget() {\r\n        Pacman player = GameController.getInstance().getPacman();\r\n        Vector2D playerDiscretePosition = new Vector2D((int)player.getPosition().getX(), (int)player.getPosition().getY());\r\n        target = new Vector2D(playerDiscretePosition.getX(), playerDiscretePosition.getY() - 1);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/YellowGhost.java b/src/logic/YellowGhost.java
--- a/src/logic/YellowGhost.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/logic/YellowGhost.java	(date 1713966062209)
@@ -1,14 +1,59 @@
 package logic;
 
+import util.Config;
+
 public class YellowGhost extends LowGhost {
-    public YellowGhost(double x, double y, double width, double height, String imgPath) {
-        super(x, y, width, height, imgPath);
+    private GhostState state;
+
+    public YellowGhost(double x, double y, double width, double height, double speed, String imgPath) {
+        super(x, y, width, height, speed, imgPath);
+        startChase();
     }
 
-    @Override
+    private void startChase() {
+        state = GhostState.CHASE;
+        updateTarget();
+        Thread chaseThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.YELLOW_GHOST_CHASE_DURATION * 1000);
+                if (getState() == GhostState.CHASE) {
+                    startScatter();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        chaseThread.start();
+    }
+
+    private void startScatter() {
+        state = GhostState.SCATTER;
+        System.out.println("Yellow Ghost State: Scatter");
+        updateTarget();
+        Thread scatterThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.YELLOW_GHOST_SCATTER_DURATION * 1000);
+                if (getState() == GhostState.SCATTER) {
+                    startChase();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        scatterThread.start();
+    }
+
     protected void updateTarget() {
         Pacman player = GameController.getInstance().getPacman();
         Vector2D playerDiscretePosition = new Vector2D((int)player.getPosition().getX(), (int)player.getPosition().getY());
-        target = new Vector2D(playerDiscretePosition.getX(), playerDiscretePosition.getY() - 1);
+        if (state == GhostState.CHASE) {
+            target = new Vector2D(playerDiscretePosition.getX(), playerDiscretePosition.getY() - 1);
+        } else if (state == GhostState.SCATTER) {
+            target = new Vector2D(Config.YELLOW_GHOST_X_ORIGIN, Config.YELLOW_GHOST_Y_ORIGIN);
+        }
+    }
+
+    public GhostState getState() {
+        return state;
     }
 }
Index: src/logic/Pacman.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic;\r\n\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.input.KeyCode;\r\nimport javafx.scene.paint.Color;\r\nimport util.Config;\r\nimport util.InputUtility;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Pacman extends Entity implements Collidable {\r\n    private Image sprite;\r\n    private Vector2D velocity;\r\n    private Vector2D nextVelocity;\r\n\r\n    public Pacman(double x, double y, double width, double height, String imgPath) {\r\n        super(x, y, width, height);\r\n        // Load the image\r\n        sprite = new Image(ClassLoader.getSystemResource(imgPath).toString());\r\n        // Initialize the velocity to 0 in both x and y direction\r\n        velocity = new Vector2D(0, 0);\r\n        nextVelocity = new Vector2D(0, 0);\r\n    }\r\n\r\n    @Override\r\n    public int getZIndex() {\r\n        return Config.PACMAN_Z_INDEX;\r\n    }\r\n\r\n    @Override\r\n    public void draw(GraphicsContext gc) {\r\n        // Draw the sprite at the current position scaled to the unit width\r\n        gc.drawImage(sprite,\r\n                position.getX() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getXPadding(),\r\n                position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),\r\n                width,\r\n                height);\r\n        gc.setFill(Color.GREEN);\r\n        gc.fillRect(position.getX() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getXPadding(),\r\n                position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),\r\n                5,\r\n                5);\r\n    }\r\n\r\n    private void getInput() {\r\n        if (InputUtility.getKeyPressed(KeyCode.W)) {\r\n            nextVelocity = new Vector2D(0, -Config.PACMAN_SPEED);\r\n        } else if (InputUtility.getKeyPressed(KeyCode.A)) {\r\n            nextVelocity = new Vector2D(-Config.PACMAN_SPEED, 0);\r\n        } else if (InputUtility.getKeyPressed(KeyCode.S)) {\r\n            nextVelocity = new Vector2D(0, Config.PACMAN_SPEED);\r\n        } else if (InputUtility.getKeyPressed(KeyCode.D)) {\r\n            nextVelocity = new Vector2D(Config.PACMAN_SPEED, 0);\r\n        }\r\n    }\r\n\r\n    private void changeVelocity() {\r\n        Vector2D currentDiscretePosition = new Vector2D((int)position.getX(), (int)position.getY());\r\n        if (position.equals(currentDiscretePosition)) {\r\n            if (nextVelocity.getCurrentDirection() == Direction.LEFT && GameController.getInstance().getMap().getMapInfo()[(int)position.getY()][(int)position.getX() - 1] == -1\r\n            || nextVelocity.getCurrentDirection() == Direction.RIGHT && GameController.getInstance().getMap().getMapInfo()[(int)position.getY()][(int)position.getX() + 1] == -1\r\n            || nextVelocity.getCurrentDirection() == Direction.UP && GameController.getInstance().getMap().getMapInfo()[(int)position.getY() - 1][(int)position.getX()] == -1\r\n            || nextVelocity.getCurrentDirection() == Direction.DOWN && GameController.getInstance().getMap().getMapInfo()[(int)position.getY() + 1][(int)position.getX()] == -1) {\r\n                velocity = nextVelocity;\r\n            } else {\r\n                Vector2D nextDiscretePosition;\r\n                if (velocity.getCurrentDirection() == null) return;\r\n                nextDiscretePosition = switch (velocity.getCurrentDirection()) {\r\n                    case LEFT -> new Vector2D(currentDiscretePosition.getX() - 1, currentDiscretePosition.getY());\r\n                    case RIGHT -> new Vector2D(currentDiscretePosition.getX() + 1, currentDiscretePosition.getY());\r\n                    case UP -> new Vector2D(currentDiscretePosition.getX(), currentDiscretePosition.getY() - 1);\r\n                    case DOWN -> new Vector2D(currentDiscretePosition.getX(), currentDiscretePosition.getY() + 1);\r\n                };\r\n                if (GameController.getInstance().getMap().isWall(nextDiscretePosition.getX(), nextDiscretePosition.getY())) {\r\n                    velocity = new Vector2D(0, 0);\r\n                }\r\n            }\r\n        } else if (velocity.isSameAxis(nextVelocity)) {\r\n            velocity = nextVelocity;\r\n        }\r\n    }\r\n\r\n    public void update(double delta) {\r\n        getInput();\r\n        changeVelocity();\r\n        move(delta);\r\n    }\r\n\r\n    private void move(double delta) {\r\n        Direction currentDirection = velocity.getCurrentDirection();\r\n        Vector2D currentDiscretePosition = new Vector2D((int)position.getX(), (int)position.getY());\r\n        if (currentDirection != null) {\r\n            if (currentDirection == Direction.LEFT || currentDirection == Direction.RIGHT) {\r\n                setY(currentDiscretePosition.getY());\r\n                if (currentDirection == Direction.LEFT) {\r\n                    Vector2D vec = new Vector2D(currentDiscretePosition.getX() - position.getX(), 0);\r\n                    if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\r\n                        setX(currentDiscretePosition.getX());\r\n                        return;\r\n                    }\r\n                } else {\r\n                    Vector2D vec = new Vector2D(currentDiscretePosition.getX() + 1 - position.getX(), 0);\r\n                    if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\r\n                        setX(currentDiscretePosition.getX() + 1);\r\n                        return;\r\n                    }\r\n                }\r\n                setX(position.getX() + velocity.getX() * GameController.getInstance().getGamePanel().getUnitWidth() * delta);\r\n            } else {\r\n                setX(currentDiscretePosition.getX());\r\n                if (currentDirection == Direction.UP) {\r\n                    Vector2D vec = new Vector2D(0, currentDiscretePosition.getY() - position.getY());\r\n                    if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\r\n                        setY(currentDiscretePosition.getY());\r\n                        return;\r\n                    }\r\n                } else {\r\n                    Vector2D vec = new Vector2D(0, currentDiscretePosition.getY() + 1 - position.getY());\r\n                    if (vec.getLength() < Config.MOVEMENT_OFFSET_THRESHOLD * GameController.getInstance().getGamePanel().getUnitWidth() && vec.getLength() > 0) {\r\n                        setY(currentDiscretePosition.getY() + 1);\r\n                        return;\r\n                    }\r\n                }\r\n                setY(position.getY() + velocity.getY() * GameController.getInstance().getGamePanel().getUnitWidth() * delta);\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Rectangle getCollisionBox() {\r\n        GamePanel gamePanel = GameController.getInstance().getGamePanel();\r\n        return new Rectangle(position.getX() * gamePanel.getUnitWidth() + gamePanel.getXPadding(), position.getY() * gamePanel.getUnitWidth() + gamePanel.getYPadding(), width, height);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/Pacman.java b/src/logic/Pacman.java
--- a/src/logic/Pacman.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/logic/Pacman.java	(date 1713966062208)
@@ -3,16 +3,15 @@
 import javafx.scene.canvas.GraphicsContext;
 import javafx.scene.image.Image;
 import javafx.scene.input.KeyCode;
-import javafx.scene.paint.Color;
 import util.Config;
 import util.InputUtility;
 
-import java.util.ArrayList;
-
 public class Pacman extends Entity implements Collidable {
     private Image sprite;
     private Vector2D velocity;
     private Vector2D nextVelocity;
+    private int health;
+    private PacmanState state;
 
     public Pacman(double x, double y, double width, double height, String imgPath) {
         super(x, y, width, height);
@@ -21,6 +20,8 @@
         // Initialize the velocity to 0 in both x and y direction
         velocity = new Vector2D(0, 0);
         nextVelocity = new Vector2D(0, 0);
+        health = Config.PACMAN_MAX_HEALTH;
+        state = PacmanState.NORMAL;
     }
 
     @Override
@@ -36,11 +37,6 @@
                 position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),
                 width,
                 height);
-        gc.setFill(Color.GREEN);
-        gc.fillRect(position.getX() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getXPadding(),
-                position.getY() * GameController.getInstance().getGamePanel().getUnitWidth() + GameController.getInstance().getGamePanel().getYPadding(),
-                5,
-                5);
     }
 
     private void getInput() {
@@ -62,6 +58,8 @@
             || nextVelocity.getCurrentDirection() == Direction.RIGHT && GameController.getInstance().getMap().getMapInfo()[(int)position.getY()][(int)position.getX() + 1] == -1
             || nextVelocity.getCurrentDirection() == Direction.UP && GameController.getInstance().getMap().getMapInfo()[(int)position.getY() - 1][(int)position.getX()] == -1
             || nextVelocity.getCurrentDirection() == Direction.DOWN && GameController.getInstance().getMap().getMapInfo()[(int)position.getY() + 1][(int)position.getX()] == -1) {
+                Vector2D nextDiscretePosition = new Vector2D(currentDiscretePosition.getX() + nextVelocity.getX() / Config.PACMAN_SPEED, currentDiscretePosition.getY() + nextVelocity.getY() / Config.PACMAN_SPEED);
+                if (nextDiscretePosition.equals(new Vector2D(23, 10))) return;
                 velocity = nextVelocity;
             } else {
                 Vector2D nextDiscretePosition;
@@ -81,10 +79,36 @@
         }
     }
 
+    private void startInvincible(long duration) {
+        Thread invincibleThread = new Thread(() -> {
+            try {
+                state = PacmanState.INVINCIBLE;
+                Thread.sleep(duration * 1000);
+                state = PacmanState.NORMAL;
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        invincibleThread.start();
+    }
+
+    private void collisionCheck() {
+        for (Ghost ghost : GameController.getInstance().getGhosts()) {
+            if (getCollisionBox().isColliding(ghost.getCollisionBox())) {
+                health--;
+                startInvincible(Config.PACMAN_HURT_INVINCIBILITY_DURATION);
+                break;
+            }
+        }
+    }
+
     public void update(double delta) {
         getInput();
         changeVelocity();
         move(delta);
+        collisionCheck();
+        // print health
+        System.out.println("Pacman Health: " + health);
     }
 
     private void move(double delta) {
@@ -132,4 +156,8 @@
         GamePanel gamePanel = GameController.getInstance().getGamePanel();
         return new Rectangle(position.getX() * gamePanel.getUnitWidth() + gamePanel.getXPadding(), position.getY() * gamePanel.getUnitWidth() + gamePanel.getYPadding(), width, height);
     }
+
+    public Vector2D getVelocity() {
+        return velocity;
+    }
 }
Index: src/logic/PacmanState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/PacmanState.java b/src/logic/PacmanState.java
new file mode 100644
--- /dev/null	(date 1713966062208)
+++ b/src/logic/PacmanState.java	(date 1713966062208)
@@ -0,0 +1,6 @@
+package logic;
+
+public enum PacmanState {
+    NORMAL,
+    INVINCIBLE
+}
Index: src/logic/GreenGhost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/GreenGhost.java b/src/logic/GreenGhost.java
new file mode 100644
--- /dev/null	(date 1713966062205)
+++ b/src/logic/GreenGhost.java	(date 1713966062205)
@@ -0,0 +1,61 @@
+package logic;
+
+import util.Config;
+
+public class GreenGhost extends LowGhost {
+    private GhostState state;
+
+    public GreenGhost(double x, double y, double width, double height, double speed, String imgPath) {
+        super(x, y, width, height, speed, imgPath);
+        startChase();
+    }
+
+    private void startChase() {
+        state = GhostState.CHASE;
+        updateTarget();
+        Thread chaseThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.GREEN_GHOST_CHASE_DURATION * 1000);
+                if (getState() == GhostState.CHASE) {
+                    startScatter();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        chaseThread.start();
+    }
+
+    private void startScatter() {
+        state = GhostState.SCATTER;
+        System.out.println("Green Ghost State: Scatter");
+        updateTarget();
+        Thread scatterThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.GREEN_GHOST_SCATTER_DURATION * 1000);
+                if (getState() == GhostState.SCATTER) {
+                    startChase();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        scatterThread.start();
+    }
+
+    protected void updateTarget() {
+        Pacman player = GameController.getInstance().getPacman();
+        Vector2D playerDiscretePosition = new Vector2D((int)player.getPosition().getX(), (int)player.getPosition().getY());
+        Vector2D playerVelocity = player.getVelocity();
+        if (state == GhostState.CHASE) {
+            target = new Vector2D(playerDiscretePosition.getX() + playerVelocity.getX() / Config.PACMAN_SPEED,
+                                  playerDiscretePosition.getY() + playerVelocity.getY() / Config.PACMAN_SPEED);
+        } else if (state == GhostState.SCATTER) {
+            target = new Vector2D(Config.GREEN_GHOST_X_ORIGIN, Config.GREEN_GHOST_Y_ORIGIN);
+        }
+    }
+
+    public GhostState getState() {
+        return state;
+    }
+}
Index: src/logic/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic;\r\n\r\n\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.paint.Color;\r\nimport render.Renderable;\r\nimport util.Config;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Comparator;\r\n\r\npublic class GameController {\r\n    private static final GameController instance = new GameController();\r\n    private Map map = new Map(Config.MAP_Y_DIMENSION, Config.MAP_X_DIMENSION, \"grid_data_out.csv\");\r\n    private ArrayList<Renderable> renderedEntities = new ArrayList<Renderable>();\r\n    private ArrayList<Ghost> ghosts = new ArrayList<Ghost>();\r\n    private Comparator<Renderable> comparator;\r\n    private Pacman pacman;\r\n    private GamePanel gamePanel;\r\n    private TileMap tileMap;\r\n\r\n    public void start(GraphicsContext gc) {\r\n        // Get the game panel\r\n        gamePanel = (GamePanel)gc.getCanvas();\r\n        // Set the comparator for sorting entities\r\n        comparator = (Renderable p, Renderable q) -> {\r\n            // Higher zIndex means the entity is rendered on top\r\n            if (p.getZIndex() == q.getZIndex()) {\r\n                return 0;\r\n            }\r\n            return (p.getZIndex() > q.getZIndex() ? -1 : 1);\r\n        };\r\n        // Create the tile map\r\n        tileMap = new TileMap(map);\r\n        // Add the tile map to the list of rendered entities\r\n        addNewEntity(tileMap);\r\n        // Create the pacman\r\n        pacman = new Pacman(Config.PACMAN_X_ORIGIN, Config.PACMAN_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), \"Pacman.PNG\");\r\n        // Add the pacman to the list of rendered entities\r\n        addNewEntity(pacman);\r\n        // Create the ghosts\r\n        addNewGhost(new YellowGhost(Config.YELLOW_GHOST_X_ORIGIN, Config.YELLOW_GHOST_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), \"YellowGhost.PNG\"));\r\n    }\r\n\r\n    public void update(double delta) {\r\n        // Update the pacman\r\n        pacman.update(delta);\r\n        // Update the ghosts\r\n        for (Ghost ghost : ghosts) {\r\n            ghost.update(delta);\r\n        }\r\n    }\r\n\r\n    public void render(GraphicsContext gc) {\r\n        // Clear the canvas\r\n        gc.clearRect(0, 0, gc.getCanvas().getWidth(), gc.getCanvas().getHeight());\r\n\r\n        // Fill the canvas with black color\r\n        gc.setFill(Color.BLACK);\r\n        gc.fillRect(0, 0, gc.getCanvas().getWidth(), gc.getCanvas().getHeight());\r\n        // Render the map\r\n        renderEntities(gc);\r\n    }\r\n\r\n    private void addNewGhost(Ghost ghost) {\r\n        ghosts.add(ghost);\r\n        addNewEntity(ghost);\r\n    }\r\n\r\n    private void addNewEntity(Renderable rendererObj) {\r\n        // Add the entity to the list of rendered entities\r\n        renderedEntities.add(rendererObj);\r\n        // Sort the list of rendered entities\r\n        renderedEntities.sort(comparator);\r\n    }\r\n\r\n    private void renderEntities(GraphicsContext gc) {\r\n        // Iterate through the list of rendered entities\r\n        for (int i = renderedEntities.size() - 1; i >= 0; i--) {\r\n            // If the entity is destroyed, remove it from the list\r\n            // Otherwise, render the entity\r\n            if (renderedEntities.get(i).isDestroyed()) {\r\n                renderedEntities.remove(i);\r\n            } else {\r\n                renderedEntities.get(i).draw(gc);\r\n            }\r\n        }\r\n    }\r\n\r\n    public Map getMap() {\r\n        return map;\r\n    }\r\n\r\n    public static GameController getInstance() {\r\n        return instance;\r\n    }\r\n\r\n    public GamePanel getGamePanel() {\r\n        return gamePanel;\r\n    }\r\n\r\n    public Pacman getPacman() {\r\n        return pacman;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/GameController.java b/src/logic/GameController.java
--- a/src/logic/GameController.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/logic/GameController.java	(date 1713966062204)
@@ -39,7 +39,9 @@
         // Add the pacman to the list of rendered entities
         addNewEntity(pacman);
         // Create the ghosts
-        addNewGhost(new YellowGhost(Config.YELLOW_GHOST_X_ORIGIN, Config.YELLOW_GHOST_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), "YellowGhost.PNG"));
+        addNewGhost(new YellowGhost(Config.YELLOW_GHOST_X_ORIGIN, Config.YELLOW_GHOST_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), Config.NORMAL_GHOST_SPEED, "YellowGhost.PNG"));
+        addNewGhost(new OrangeGhost(Config.ORANGE_GHOST_X_ORIGIN, Config.ORANGE_GHOST_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), Config.NORMAL_GHOST_SPEED, "OrangeGhost.PNG"));
+        addNewGhost(new GreenGhost(Config.GREEN_GHOST_X_ORIGIN, Config.GREEN_GHOST_Y_ORIGIN, gamePanel.getUnitWidth(), gamePanel.getUnitWidth(), Config.NORMAL_GHOST_SPEED, "GreenGhost.PNG"));
     }
 
     public void update(double delta) {
@@ -102,4 +104,8 @@
     public Pacman getPacman() {
         return pacman;
     }
+
+    public ArrayList<Ghost> getGhosts() {
+        return ghosts;
+    }
 }
Index: src/logic/OrangeGhost.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/OrangeGhost.java b/src/logic/OrangeGhost.java
new file mode 100644
--- /dev/null	(date 1713966062205)
+++ b/src/logic/OrangeGhost.java	(date 1713966062205)
@@ -0,0 +1,59 @@
+package logic;
+
+import util.Config;
+
+public class OrangeGhost extends LowGhost {
+    private GhostState state;
+
+    public OrangeGhost(double x, double y, double width, double height, double speed, String imgPath) {
+        super(x, y, width, height, speed, imgPath);
+        startChase();
+    }
+
+    private void startChase() {
+        state = GhostState.CHASE;
+        updateTarget();
+        Thread chaseThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.ORANGE_GHOST_CHASE_DURATION * 1000);
+                if (getState() == GhostState.CHASE) {
+                    startScatter();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        chaseThread.start();
+    }
+
+    private void startScatter() {
+        state = GhostState.SCATTER;
+        System.out.println("Orange Ghost State: Scatter");
+        updateTarget();
+        Thread scatterThread = new Thread(() -> {
+            try {
+                Thread.sleep(Config.ORANGE_GHOST_SCATTER_DURATION * 1000);
+                if (getState() == GhostState.SCATTER) {
+                    startChase();
+                }
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+        });
+        scatterThread.start();
+    }
+
+    protected void updateTarget() {
+        Pacman player = GameController.getInstance().getPacman();
+        Vector2D playerDiscretePosition = new Vector2D((int)player.getPosition().getX(), (int)player.getPosition().getY());
+        if (state == GhostState.CHASE) {
+            target = new Vector2D(playerDiscretePosition.getX(), playerDiscretePosition.getY());
+        } else if (state == GhostState.SCATTER) {
+            target = new Vector2D(Config.ORANGE_GHOST_X_ORIGIN, Config.ORANGE_GHOST_Y_ORIGIN);
+        }
+    }
+
+    public GhostState getState() {
+        return state;
+    }
+}
Index: src/logic/GhostState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/logic/GhostState.java b/src/logic/GhostState.java
new file mode 100644
--- /dev/null	(date 1713966062205)
+++ b/src/logic/GhostState.java	(date 1713966062205)
@@ -0,0 +1,7 @@
+package logic;
+
+public enum GhostState {
+    CHASE,
+    SCATTER,
+    FRIGHTENED
+}
Index: src/util/Config.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package util;\r\n\r\npublic class Config {\r\n    public static final int MAP_X_DIMENSION = 47;\r\n    public static final int MAP_Y_DIMENSION = 23;\r\n    public static final double PACMAN_SPEED = 0.1;\r\n    public static final int PACMAN_X_ORIGIN = 23;\r\n    public static final int PACMAN_Y_ORIGIN = 17;\r\n    public static final int FPS_CAP = 60;\r\n    public static final int PACMAN_Z_INDEX = 1;\r\n    public static final int ITEM_Z_INDEX = 1;\r\n    public static final int TILE_MAP_Z_INDEX = 0;\r\n    public static final double MOVEMENT_OFFSET_THRESHOLD = 0.005;\r\n    public static final double GHOST_SPEED = 0.11;\r\n    public static final int GHOST_X_ORIGIN = 23;\r\n    public static final int GHOST_Y_ORIGIN = 17;\r\n    public static final int GHOST_Z_INDEX = 1;\r\n    public static final int YELLOW_GHOST_X_ORIGIN = 1;\r\n    public static final int YELLOW_GHOST_Y_ORIGIN = 1;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/util/Config.java b/src/util/Config.java
--- a/src/util/Config.java	(revision cdb993f4efb6ecabdd474112932df55884c4b271)
+++ b/src/util/Config.java	(date 1713966073599)
@@ -6,15 +6,30 @@
     public static final double PACMAN_SPEED = 0.1;
     public static final int PACMAN_X_ORIGIN = 23;
     public static final int PACMAN_Y_ORIGIN = 17;
-    public static final int FPS_CAP = 60;
     public static final int PACMAN_Z_INDEX = 1;
+<<<<<<< HEAD
     public static final int ITEM_Z_INDEX = 1;
+=======
+    public static final int PACMAN_MAX_HEALTH = 3;
+    public static final int PACMAN_HURT_INVINCIBILITY_DURATION = 3;
+    public static final int FPS_CAP = 60;
+>>>>>>> refs/remotes/origin/main
     public static final int TILE_MAP_Z_INDEX = 0;
     public static final double MOVEMENT_OFFSET_THRESHOLD = 0.005;
-    public static final double GHOST_SPEED = 0.11;
     public static final int GHOST_X_ORIGIN = 23;
     public static final int GHOST_Y_ORIGIN = 17;
+    public static final double NORMAL_GHOST_SPEED = 0.11;
     public static final int GHOST_Z_INDEX = 1;
     public static final int YELLOW_GHOST_X_ORIGIN = 1;
     public static final int YELLOW_GHOST_Y_ORIGIN = 1;
+    public static final int YELLOW_GHOST_CHASE_DURATION = 10;
+    public static final int YELLOW_GHOST_SCATTER_DURATION = 5;
+    public static final int ORANGE_GHOST_CHASE_DURATION = 7;
+    public static final int ORANGE_GHOST_SCATTER_DURATION = 4;
+    public static final int ORANGE_GHOST_X_ORIGIN = 45;
+    public static final int ORANGE_GHOST_Y_ORIGIN = 1;
+    public static final int GREEN_GHOST_CHASE_DURATION = 10;
+    public static final int GREEN_GHOST_SCATTER_DURATION = 3;
+    public static final int GREEN_GHOST_X_ORIGIN = 45;
+    public static final int GREEN_GHOST_Y_ORIGIN = 21;
 }
